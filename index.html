<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stack & Snap - Full Juice</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #050508; font-family: sans-serif; user-select: none; -webkit-user-select: none; }
        #ui-root { position: absolute; inset: 0; pointer-events: none; color: white; z-index: 100; text-align: center; }
        .score { position: absolute; top: 40px; left: 0; right: 0; font-size: 4rem; font-weight: 900; opacity: 0.9; }
        .overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); pointer-events: auto; backdrop-filter: blur(10px); }
        .btn { padding: 20px 50px; background: #00ffff; color: #000; border: none; border-radius: 50px; font-weight: 900; font-size: 1.2rem; cursor: pointer; margin-top: 20px; }
        .combo { color: #00ffff; font-style: italic; font-weight: 800; font-size: 1.5rem; margin-top: 10px; }
    </style>
</head>
<body>
    <div id="ui-root"></div>
    <div id="root"></div>

    <script>
        const CONFIG = {
            PERFECT_LIMIT: 0.15,
            INITIAL_SPEED: 0.15,
            SPEED_INC: 0.005,
        };

        let state = {
            status: 'START',
            score: 0,
            combo: 0,
            speed: CONFIG.INITIAL_SPEED,
            stack: [], debris: [], 
            axis: 'x', direction: 1,
            activeBlock: null, shake: 0
        };

        const Audio = {
            ctx: null,
            scale: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
            init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            play(isPerfect) {
                this.init();
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                
                if (isPerfect) {
                    const note = state.score % 8;
                    const octave = Math.floor(state.score / 8);
                    osc.frequency.setValueAtTime(this.scale[note] * Math.pow(2, octave), this.ctx.currentTime);
                    osc.type = 'sine';
                    g.gain.setValueAtTime(0.2, this.ctx.currentTime);
                } else {
                    osc.frequency.setValueAtTime(120, this.ctx.currentTime);
                    osc.type = 'triangle';
                    g.gain.setValueAtTime(0.15, this.ctx.currentTime);
                }

                g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.4);
                osc.connect(g); g.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.4);
            }
        };

        let scene, camera, renderer, stars;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050508, 10, 50);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('root').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(5, 10, 5);
            scene.add(light);

            // Restored Stars
            const starGeo = new THREE.BufferGeometry();
            const starPoints = [];
            for(let i=0; i<1000; i++) starPoints.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPoints, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0x888888, size: 0.1 }));
            scene.add(stars);

            reset();
            animate();
        }

        function getGlassMat(color) {
            return new THREE.MeshPhysicalMaterial({
                color: color, transmission: 0.7, thickness: 1, roughness: 0.1, emissive: color, emissiveIntensity: 0.2
            });
        }

        function reset() {
            state.stack.forEach(m => scene.remove(m));
            state.debris.forEach(m => scene.remove(m));
            state.stack = []; state.debris = []; state.score = 0; state.combo = 0;
            state.speed = CONFIG.INITIAL_SPEED; state.status = 'START';
            
            const base = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 4), getGlassMat(0x00ffff));
            scene.add(base); state.stack.push(base);
            renderUI();
        }

        function spawn() {
            const prev = state.stack[state.stack.length-1];
            state.axis = state.axis === 'x' ? 'z' : 'x';
            const color = new THREE.Color().setHSL((state.score * 0.1) % 1, 0.7, 0.5);
            const mesh = new THREE.Mesh(prev.geometry.clone(), getGlassMat(color));
            mesh.position.set(prev.position.x, state.stack.length, prev.position.z);
            mesh.position[state.axis] = 10 * state.direction;
            scene.add(mesh);
            state.activeBlock = mesh;
        }

        function place() {
            const active = state.activeBlock;
            const prev = state.stack[state.stack.length-1];
            const size = state.axis === 'x' ? active.geometry.parameters.width : active.geometry.parameters.depth;
            const delta = active.position[state.axis] - prev.position[state.axis];
            const overlap = size - Math.abs(delta);

            if (overlap <= 0) {
                state.status = 'GAMEOVER';
                renderUI();
                return;
            }

            if (Math.abs(delta) < CONFIG.PERFECT_LIMIT) {
                active.position[state.axis] = prev.position[state.axis];
                state.combo++;
                Audio.play(true);
            } else {
                state.combo = 0;
                // Debris Logic
                const debrisSize = Math.abs(delta);
                const debrisGeom = state.axis === 'x' ? 
                    new THREE.BoxGeometry(debrisSize, 1, active.geometry.parameters.depth) :
                    new THREE.BoxGeometry(active.geometry.parameters.width, 1, debrisSize);
                
                const debris = new THREE.Mesh(debrisGeom, active.material.clone());
                debris.position.copy(active.position);
                debris.position[state.axis] += (overlap/2 + debrisSize/2) * Math.sign(delta);
                scene.add(debris);
                state.debris.push({ mesh: debris, vel: 0, rot: Math.random() * 0.1 });

                // Slice Active
                const newSize = overlap;
                active.geometry.dispose();
                active.geometry = state.axis === 'x' ? 
                    new THREE.BoxGeometry(newSize, 1, active.geometry.parameters.depth) :
                    new THREE.BoxGeometry(active.geometry.parameters.width, 1, newSize);
                active.position[state.axis] = prev.position[state.axis] + (delta/2);
                Audio.play(false);
            }

            state.stack.push(active);
            state.score++;
            state.speed += CONFIG.SPEED_INC;
            spawn();
            renderUI();
        }

        function renderUI() {
            const root = document.getElementById('ui-root');
            if (state.status === 'START') {
                root.innerHTML = `<div class="overlay"><h1>STACK & SNAP</h1><button class="btn" onclick="state.status='PLAYING'; spawn(); renderUI();">START</button></div>`;
            } else if (state.status === 'PLAYING') {
                root.innerHTML = `<div class="score">${state.score}${state.combo > 1 ? `<div class="combo">COMBO x${state.combo}</div>` : ''}</div>`;
            } else {
                root.innerHTML = `<div class="overlay"><h2>CRASHED</h2><h1>${state.score}</h1><button class="btn" onclick="location.reload()">RETRY</button></div>`;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (state.status === 'PLAYING' && state.activeBlock) {
                state.activeBlock.position[state.axis] += state.direction * state.speed;
                if (Math.abs(state.activeBlock.position[state.axis]) > 10) state.direction *= -1;
            }

            // Handle Debris falling
            state.debris.forEach((d, i) => {
                d.vel -= 0.02;
                d.mesh.position.y += d.vel;
                d.mesh.rotation.x += d.rot;
                if (d.mesh.position.y < -10) {
                    scene.remove(d.mesh);
                    state.debris.splice(i, 1);
                }
            });

            if (stars) stars.rotation.y += 0.001;

            const targetY = 10 + state.stack.length;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            camera.lookAt(0, state.stack.length - 2, 0);
            
            renderer.render(scene, camera);
        }

        window.addEventListener('mousedown', () => { if(state.status === 'PLAYING') place(); });
        window.addEventListener('touchstart', (e) => { e.preventDefault(); if(state.status === 'PLAYING') place(); });

        init();
    </script>
</body>
</html>
